import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.BreadthFirstDirectedPaths;
import java.lang.IllegalArgumentException;

/*
 * Implementation of Shortest Ancestral Paths (SAP) using BFS for directed graphs.
 */
public class SAP {
	private final Digraph G;		// Directed Graph needs processing
	
	/*
	 * Check if the input is within range
	 */
	private void validate(int v)
	{
		if (v < 0 || v >= G.V()) 
			throw new IllegalArgumentException();
	}
	
	private void validate(Iterable<Integer> v)
	{
		for (int w: v)
			if (w < 0 || w >= G.V())
				throw new IllegalArgumentException();
	}
	
	/*
	 * Constructor takes a directed graph (not necessarily a DAG)
	 */
	public SAP(Digraph G)
	{
		this.G = G;
	}
	
	/*
	 * Length of SAP between vertex v and vertex w, -1 if no such paths
	 */
	public int length(int v, int w)
	{
		validate(v);
		validate(w);
		
		BreadthFirstDirectedPaths bfsV = new BreadthFirstDirectedPaths(G, v);
		BreadthFirstDirectedPaths bfsW = new BreadthFirstDirectedPaths(G, w);
		
		int minDist = Integer.MAX_VALUE;
		for (int i = 0; i < G.V(); i++)
			if (bfsV.hasPathTo(i) && bfsW.hasPathTo(i))
				if (bfsV.distTo(i) + bfsW.distTo(i) < minDist)			// Find the minimum distance
					minDist = bfsV.distTo(i) + bfsW.distTo(i);
		if (minDist == Integer.MAX_VALUE) return -1;
		return minDist;

	}
	
	/*
	 * A common ancestor of vertex v and vertex w participating in the SAP, -1 if no such paths
	 */
	public int ancestor(int v, int w)
	{
		validate(v);
		validate(w);
		
		BreadthFirstDirectedPaths bfsV = new BreadthFirstDirectedPaths(G, v);
		BreadthFirstDirectedPaths bfsW = new BreadthFirstDirectedPaths(G, w);
		
		int minDist = Integer.MAX_VALUE;
		int ancestor = -1;
		for (int i = 0; i < G.V(); i++)
			if (bfsV.hasPathTo(i) && bfsW.hasPathTo(i))
				if (bfsV.distTo(i) + bfsW.distTo(i) < minDist)	
				{
					minDist = bfsV.distTo(i) + bfsW.distTo(i);
					ancestor = i;
				}
		return ancestor;
	}
	
	/*
	 * Length of SAP between any vertex in v and any vertex in w, -1 if no such paths
	 */
	public int length(Iterable<Integer> v, Iterable<Integer> w)
	{
		validate(v);
		validate(w);
		
		BreadthFirstDirectedPaths bfsV = new BreadthFirstDirectedPaths(G, v);
		BreadthFirstDirectedPaths bfsW = new BreadthFirstDirectedPaths(G, w);
		
		int minDist = Integer.MAX_VALUE;
		for (int i = 0; i < G.V(); i++)
			if (bfsV.hasPathTo(i) && bfsW.hasPathTo(i))
				if (bfsV.distTo(i) + bfsW.distTo(i) < minDist)			// Find the minimum distance
					minDist = bfsV.distTo(i) + bfsW.distTo(i);
		if (minDist == Integer.MAX_VALUE) return -1;
		return minDist;
	}
	
	/*
	 * A common ancestor of any vertex in v and any vertex in w participating in the SAP, -1 if 
	 * no such paths
	 */
	public int ancestor(Iterable<Integer> v, Iterable<Integer> w)
	{
		validate(v);
		validate(w);
		
		BreadthFirstDirectedPaths bfsV = new BreadthFirstDirectedPaths(G, v);
		BreadthFirstDirectedPaths bfsW = new BreadthFirstDirectedPaths(G, w);
		
		int minDist = Integer.MAX_VALUE;
		int ancestor = -1;
		for (int i = 0; i < G.V(); i++)
			if (bfsV.hasPathTo(i) && bfsW.hasPathTo(i))
				if (bfsV.distTo(i) + bfsW.distTo(i) < minDist)	
				{
					minDist = bfsV.distTo(i) + bfsW.distTo(i);
					ancestor = i;
				}
		return ancestor;
	}
}
