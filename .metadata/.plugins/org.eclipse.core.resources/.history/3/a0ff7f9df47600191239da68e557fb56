import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.Digraph;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.lang.IllegalArgumentException;

/*
 * Directed Graph implementation of WordNet. To satisfy the running time requirements, the class also
 * contains a hash table of nouns (key = nouns, value = list of ID of synsets of the noun)
 */

public class WordNet {
	private Digraph G;									// Directed-graph representation of WordNet
	private HashMap<String, ArrayList<Integer>> nouns;	// Hash table of nouns
	
	/*
	 * Constructor takes the name of two input files: synsets and hypernyms
	 */
	public WordNet(String synsets, String hypernyms)
	{
		In synsetsFile = new In(synsets);				
		In hypernymsFile = new In(hypernyms);
		
		nouns = new HashMap<String, ArrayList<Integer>>();
		int v = 0;										// Number of synsets
		while (synsetsFile.hasNextLine())				
		{
			String inLine = synsetsFile.readLine();
			String[] input = inLine.split(","); 
			
			int id = Integer.parseInt(input[0]);
			String synset = input[1];
			String[] nounSet = synset.split(" ");
			
			for (String noun: nounSet)
			{
				if (!nouns.containsKey(noun))			// Create a new key if the noun is not in Table
					nouns.put(noun, new ArrayList<Integer>());
				nouns.get(noun).add(id);				// Add the synset ID into the ID list of the noun
			}
			
			v++;										// Increase the number of WordNet vertices
		}
		
		G = new Digraph(v);		
		while (hypernymsFile.hasNextLine())
		{
			String inLine = hypernymsFile.readLine();
			String[] input = inLine.split(",");
			
			int id = Integer.parseInt(input[0]);
			for (int i = 1; i < input.length; i++)
				G.addEdge(id, Integer.parseInt(input[i]));	// Create an edge (hypernym)
		}
		
		int root = -1;
		for (int i = 0; i < G.V(); i++)
			if (G.outdegree(i) == 0)						// Find the root of the 
			{
				root = i;
				break;
			}
		if (root == -1) throw new IllegalArgumentException();
		
		Digraph revG = G.reverse();
		LinkedList<Integer> q = new LinkedList<Integer>();
		boolean[] mark = new boolean[v];
		
		q.add(root);
		while (!q.isEmpty())
		{
			int current = q.remove();
			if (mark[current]) throw new IllegalArgumentException();	// throw exception because of cycle
			mark[current] = true;
			for (int w : revG.adj(current))
				q.add(w);
		}
		
		for (int i = 0; i < G.V(); i++)
			if (!mark[i]) throw new IllegalArgumentException();			
	}
	
	/*
	 * Returns all WordNet nouns
	 */
	public Iterable<String> nouns()
	{
		return nouns.keySet();
	}
}
